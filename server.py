import bcrypt
from flask import Flask, request, make_response,jsonify
from flask_restful import Resource, Api
from pymongo import MongoClient
from json import JSONEncoder
from bson.objectid import ObjectId
from functools import wraps


app = Flask(__name__)

mongo = MongoClient('localhost', 27017)

app.db = mongo.eventure_db

app.bcrypt_rounds = 12

api = Api(app)


# basic flask application with an initial route.


@app.route('/eventure/api/v1.1/')
def welcome():
	return '<h1>Welcome to the eventure API</h1>'


# Authentication code.
def check_auth(username, password):
    # check_auth should access the database and check if the username + password are correct.
    # create a collection to hold the users.
    user_collection = app.db.users
    user = user_collection.find_one({'username': username})

    if user is None:
    	return False
    else:
    	# check if hash generated matches stored hash
    	encodedPassword = password.encode('utf-8')
    	if bcrypt.hashpw(encodedPassword, user['password']) == user['password']:
    		return True
    	else:
    		return False


def requires_auth(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        auth = request.authorization
        if not auth or not check_auth(auth.username, auth.password):
            message = {'error': 'Basic Auth Required.'}
            resp = jsonify(message)
            resp.status_code = 401
            return resp

        return f(*args, **kwargs)
    return decorated


# ideally the app should process http requests from the iOS front end,
# query the db and return a response to the front end with the appropriate data.


# We store Events, Users, and Messages
# Need classes for each one
# Each class should implement the http method that can be performed on them


# the client that calls this endpoint provides a JSON body as part of the HTTP-
# request
# implement REST resources
class Event(Resource):

	# create a new event on the server
    @requires_auth
	def post(self):

		# access the JSON that the client provided
		new_event = request.json
        	new_event['location'] = request.get_json('location')
        	new_event['startDate'] = request.get_json('startDate')
        	new_event['endDate'] = request.get_json('endDate')
        	new_event['description'] = request.get_json('description')
        	new_event['avatar'] = request.get_json('avatar')


		# creates a new collection for events
		event_collection = app.db.events

		# insert the json document into the new collection
		result = event_collection.insert_one(new_event)

		# find an event by a specific id
		event = event_collection.find_one({'_id': ObjectId(result.inserted_id)})

		# return the selected document to the client.
		# the client can now retrieve _id generated by mongoDB and know
		# which id is associated with the new document on the server
		return event


	# show a particular event
    @requires_auth
	def get(self, event_id=None):

        if event_id is None:
            event_collection = app.db.events
            events = list(event_collection.find({'user': request.authorization.username}))
            return trips

        else:
            event_collection = app.db.events
            event = event_collection.find_one({'_id': ObjectId(event_id), 'user': request.authorization.username})

            if event is None:
                return (None, 404, None)

            else:
                return event



		# # create a collection for events
		# # select the document the client is trying to access
		# event_collection = app.db.events

		# # find one event by its id
		# # build a query based on event_id that we recieved as part of
		# # the clients request
		# event = event_collection.find_one({'_id': ObjectId(event_id)})

		# # if there is no event
		# if event is None:

		# 	# transform an empty array to json
		# 	response = jsonify(data=[])

		# 	# return status code 404 indicating no data found
		# 	response.status_code = 404
		# 	return response
		
		# else:

		# 	# otherwise return the document to the client
		# 	return event


# User resource
class User(Resource):

    def post(self):
        if (request.get_json('username') is None
                or request.get_json('password') is None):
                return ({'error':  'Request requires username and password'},
                        400,
                        None)

        user_collection = app.db.users
        user = user_collection.find_one({'username': request.json['username']})

        if user is not None:
            return ({'error': 'Username already in use'}, 400, None)
        else:
            encodedPassword = request.json['password'].encode('utf-8')
            hashed = bcrypt.hashpw(
                encodedPassword, bcrypt.gensalt(app.bcrypt_rounds))
            request.json['password'] = hashed
            user_collection.insert_one(request.json)

    @requires_auth
    def get(self):
        return (None, 200, None)



# Mapping between Routes and Resources
# a route defines a url that can be called by a client application.

# the first parameter indicates the resource that we want to map to a specific URL.
# we then next have a collection of different URLs that map to that resource
# the first one /event/ is without a specific object id.  This endpoint is used
# to operate on the collection of events.

# the second endpoint takes an object id, e.g /event/1 this endpoint operates on
# a sepcific event.

# this way the server will know which class to call when a specific URL is requested
# by the client.
api.add_resource(Event, '/eventure/api/v1.1/event/', '/eventure/api/v1.1/event/<string:event_id>')
api.add_resource(User, '/eventure/api/v1.1/user/')



# Must define a custom JSON Serializer for flask_restful
# this is because ObjectId is not a string, and therefore,
# Flask's default serializer cannot serialize it.
@api.representation('application/json')
def output_json(data, code, headers=None):
	resp = make_response(JSONEncoder().encode(data), code)
	resp.headers.extend(headers or {})
	return resp 

# a JSON Encoder takes python objects, and turns them
# into a JSON text representation.



if __name__ == '__main__':
	app.config['TRAP_BAD_REQUEST_ERRORS'] = True
	app.run(host='localhost', port=8789, debug=True)



# BREAKDOWN
# Clients make requests to the server CLIENT ----> SERVER
# Clients requests provides a json body, which indicates
# the document that the client is searching for.
# the client makes a request to a specific endpoint e.g event
# for JSON document information.

# the Resource then defines http methods that will process the clients
# request and return the appropriate information

# finally the endpoint gets mapped to a URL that will tell the server which
# class to call when a specific URL is requested by the client.

